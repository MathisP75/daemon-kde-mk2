import assert from 'assert';
import fs from 'fs';
import path, { resolve } from 'path';
import { globbySync, isDynamicPattern } from 'globby';
import multimatch from 'multimatch';
import normalize from 'normalize-path';
import File from 'vinyl';
import { getCommonPath, globify, render } from '../util.js';
function applyProcessingFunc(process, contents, filename, destination) {
    const output = process(contents, filename, destination);
    return Buffer.isBuffer(output) ? output : Buffer.from(output);
}
export function copy(from, to, options, context, tplSettings) {
    to = path.resolve(to);
    options = options ?? {};
    const { fromBasePath } = options;
    if (fromBasePath) {
        const applyBasePath = (from) => (path.isAbsolute(from) ? from : path.resolve(fromBasePath, from));
        from = Array.isArray(from) ? from.map(applyBasePath) : applyBasePath(from);
    }
    let files = [];
    if (options.noGlob) {
        const fromFiles = Array.isArray(from) ? from : [from];
        files = fromFiles.filter((filepath) => this.store.existsInMemory(filepath) || fs.existsSync(filepath));
    }
    else {
        const fromGlob = globify(from);
        const globOptions = { ...options.globOptions, nodir: true };
        const diskFiles = globbySync(fromGlob, globOptions).map((file) => path.resolve(file));
        const storeFiles = [];
        this.store.each((file) => {
            const normalizedFilepath = normalize(file.path);
            // The store may have a glob path and when we try to copy it will fail because not real file
            if (!diskFiles.includes(file.path) &&
                !isDynamicPattern(normalizedFilepath) &&
                multimatch([normalizedFilepath], fromGlob).length !== 0) {
                storeFiles.push(file.path);
            }
        });
        files = diskFiles.concat(storeFiles);
    }
    let generateDestination = () => to;
    if (Array.isArray(from) || !this.exists(from) || (isDynamicPattern(normalize(from)) && !options.noGlob)) {
        assert(!this.exists(to) || fs.statSync(to).isDirectory(), 'When copying multiple files, provide a directory as destination');
        const processDestinationPath = options.processDestinationPath || ((path) => path);
        const root = fromBasePath ?? getCommonPath(from);
        generateDestination = (filepath) => {
            const toFile = path.relative(root, filepath);
            return processDestinationPath(path.join(to, toFile));
        };
    }
    // Sanity checks: Makes sure we copy at least one file.
    assert(options.ignoreNoMatch || files.length > 0, 'Trying to copy from a source that does not exist: ' + from);
    files.forEach((file) => {
        let toFile = generateDestination(file);
        if (context) {
            toFile = render(toFile, context, { ...tplSettings, cache: false });
        }
        this._copySingle(file, toFile, options);
    });
}
export function _copySingle(from, to, options = {}) {
    assert(this.exists(from), 'Trying to copy from a source that does not exist: ' + from);
    const file = this.store.get(from);
    to = resolve(to);
    let { contents } = file;
    if (!contents) {
        throw new Error(`Cannot copy empty file ${from}`);
    }
    if (options.process) {
        contents = applyProcessingFunc(options.process, contents, file.path, to);
    }
    if (options.append) {
        if (!this.store.existsInMemory) {
            throw new Error('Current mem-fs is not compatible with append');
        }
        if (this.store.existsInMemory(to)) {
            this.append(to, contents, { create: true, ...options });
            return;
        }
    }
    if (File.isVinyl(file)) {
        this._write(Object.assign(file.clone({ contents: false, deep: false }), {
            contents,
            path: to,
        }));
    }
    else {
        this._write(new File({
            contents,
            stat: file.stat ?? fs.statSync(file.path),
            path: to,
            history: [file.path],
        }));
    }
}
